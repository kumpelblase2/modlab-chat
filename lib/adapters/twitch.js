// Generated by CoffeeScript 1.8.0
(function() {
  var Adapter, Bot, ChatUser, EnterMessage, Irc, IrcResponse, LeaveMessage, Log, Response, TextMessage, TwitchBot, logger, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('../index'), ChatUser = _ref.ChatUser, Bot = _ref.Bot, Adapter = _ref.Adapter, TextMessage = _ref.TextMessage, EnterMessage = _ref.EnterMessage, LeaveMessage = _ref.LeaveMessage, Response = _ref.Response;

  IrcResponse = (function(_super) {
    __extends(IrcResponse, _super);

    function IrcResponse() {
      return IrcResponse.__super__.constructor.apply(this, arguments);
    }

    IrcResponse.prototype.sendPrivate = function() {
      var strings, _ref1;
      strings = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref1 = this.bot.adapter).sendPrivate.apply(_ref1, [this.envelope].concat(__slice.call(strings)));
    };

    return IrcResponse;

  })(Response);

  Irc = require('irc');

  Log = require('log');

  logger = sails.log;

  TwitchBot = (function(_super) {
    __extends(TwitchBot, _super);

    function TwitchBot() {
      return TwitchBot.__super__.constructor.apply(this, arguments);
    }

    TwitchBot.prototype.send = function() {
      var envelope, str, strings, target, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      target = this._getTargetFromEnvelope(envelope);
      if (!target) {
        return logger.error("ERROR: Not sure who to send to. envelope=", envelope);
      }
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.bot.say(target, str));
      }
      return _results;
    };

    TwitchBot.prototype.emote = function() {
      var envelope, str, strings, target, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      target = this._getTargetFromEnvelope(envelope);
      if (!target) {
        return logger.error("ERROR: Not sure who to send to. envelope=", envelope);
      }
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.bot.action(target, str));
      }
      return _results;
    };

    TwitchBot.prototype.reply = function() {
      var envelope, str, strings, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.send(envelope.user, "" + envelope.user.name + ": " + str));
      }
      return _results;
    };

    TwitchBot.prototype.join = function(channel) {
      var self;
      self = this;
      return this.bot.join(channel, function() {
        var selfUser;
        logger.info('joined %s', channel);
        selfUser = self.getUserFromName(self.bot.name);
        return self.receive(new EnterMessage(selfUser));
      });
    };

    TwitchBot.prototype.part = function(channel) {
      var self;
      self = this;
      return this.bot.part(channel, function() {
        var selfUser;
        logger.info('left %s', channel);
        selfUser = self.getUserFromName(self.bot.name);
        return self.receive(new LeaveMessage(selfUser));
      });
    };

    TwitchBot.prototype.getUserFromName = function(name) {
      return new ChatUser(name);
    };

    TwitchBot.prototype.getUserFromId = function(id) {
      return new ChatUser(id);
    };

    TwitchBot.prototype.createUser = function(channel, from) {
      var user;
      user = this.getUserFromId(from);
      user.name = from;
      if (channel.match(/^[&#]/)) {
        user.room = channel;
      } else {
        user.room = null;
      }
      return user;
    };

    TwitchBot.prototype.command = function() {
      var command, strings, _ref1;
      command = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.bot).send.apply(_ref1, [command].concat(__slice.call(strings)));
    };

    TwitchBot.prototype.checkCanStart = function() {
      if (!this.chat.name) {
        throw new Error("Nick is not defined");
      } else if (!sails.config.chat.twitch.token) {
        throw new Error("Bot chat token is not defined");
      } else if (!sails.config.chat.twitch.room) {
        throw new Error("Room is not defined");
      }
    };

    TwitchBot.prototype.unfloodProtection = function(unflood) {
      return unflood === 'true' || !isNaN(parseInt(unflood));
    };

    TwitchBot.prototype.unfloodProtectionDelay = function(unflood) {
      var unfloodProtection, unfloodValue;
      unfloodProtection = this.unfloodProtection(unflood);
      unfloodValue = parseInt(unflood) || 1000;
      if (unfloodProtection) {
        return unfloodValue;
      } else {
        return 0;
      }
    };

    TwitchBot.prototype.run = function() {
      var bot, client_options, identify_args, next_id, options, self, user_id;
      self = this;
      this.checkCanStart();
      options = {
        nick: this.chat.name,
        realName: this.chat.name,
        port: sails.config.chat.twitch.port || 6667,
        rooms: [sails.config.chat.twitch.room],
        server: sails.config.chat.twitch.server || 'irc.twitch.tv',
        password: sails.config.chat.twitch.token,
        ignoreUsers: [],
        nickpass: null,
        nickusername: this.chat.name,
        connectCommand: null,
        fakessl: false,
        certExpired: false,
        unflood: true,
        debug: sails.config.chat.twitch.debug || false,
        usessl: false,
        userName: this.chat.name
      };
      client_options = {
        userName: options.userName,
        realName: options.realName,
        password: options.password,
        debug: options.debug,
        port: options.port,
        stripColors: true,
        secure: options.usessl,
        selfSigned: options.fakessl,
        certExpired: options.certExpired,
        floodProtection: this.unfloodProtection(options.unflood),
        floodProtectionDelay: this.unfloodProtectionDelay(options.unflood)
      };
      if (!options.nickpass) {
        client_options['channels'] = options.rooms;
      }
      this.chat.Response = IrcResponse;
      this.chat.name = options.nick;
      bot = new Irc.Client(options.server, options.nick, client_options);
      next_id = 1;
      user_id = {};
      if (options.nickpass != null) {
        identify_args = "";
        if (options.nickusername != null) {
          identify_args += "" + options.nickusername + " ";
        }
        identify_args += "" + options.nickpass;
        bot.addListener('notice', function(from, to, text) {
          var room, _i, _len, _ref1, _results;
          if (from === 'NickServ' && text.toLowerCase().indexOf('identify') !== -1) {
            return bot.say('NickServ', "identify " + identify_args);
          } else if (options.nickpass && from === 'NickServ' && (text.indexOf('Password accepted') !== -1 || text.indexOf('identified') !== -1)) {
            _ref1 = options.rooms;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              room = _ref1[_i];
              _results.push(this.join(room));
            }
            return _results;
          }
        });
      }
      if (options.connectCommand != null) {
        bot.addListener('registered', function(message) {
          var strings;
          strings = options.connectCommand.split(" ");
          return self.command.apply(self, [strings.shift()].concat(__slice.call(strings)));
        });
      }
      bot.addListener('names', function(channel, nicks) {
        var nick, _results;
        _results = [];
        for (nick in nicks) {
          _results.push(self.createUser(channel, nick));
        }
        return _results;
      });
      bot.addListener('notice', function(from, to, message) {
        var user;
        if (!from) {
          return;
        }
        if (__indexOf.call(options.ignoreUsers, from) >= 0) {
          logger.info('Ignoring user: %s', from);
          return;
        }
        logger.info("NOTICE from " + from + " to " + to + ": " + message);
        user = self.createUser(to, from);
        return self.receive(new TextMessage(user, message));
      });
      bot.addListener('message', function(from, to, message) {
        var user;
        if (options.nick.toLowerCase() === to.toLowerCase()) {
          return;
        }
        if (__indexOf.call(options.ignoreUsers, from) >= 0) {
          logger.info('Ignoring user: %s', from);
          return;
        }
        logger.debug("From " + from + " to " + to + ": " + message);
        user = self.createUser(to, from);
        if (user.room) {
          logger.info("" + to + " <" + from + "> " + message);
        } else {
          if (message.indexOf(to) !== 0) {
            message = "" + to + ": " + message;
          }
          logger.debug("msg <" + from + "> " + message);
        }
        return self.receive(new TextMessage(user, message));
      });
      bot.addListener('action', function(from, to, message) {
        var user;
        logger.debug(" * From " + from + " to " + to + ": " + message);
        if (__indexOf.call(options.ignoreUsers, from) >= 0) {
          logger.info('Ignoring user: %s', from);
          return;
        }
        user = self.createUser(to, from);
        if (user.room) {
          logger.debug("" + to + " * " + from + " " + message);
        } else {
          logger.debug("msg <" + from + "> " + message);
        }
        return self.receive(new TextMessage(user, message));
      });
      bot.addListener('error', function(message) {
        return logger.error('ERROR: %s: %s', message.command, message.args.join(' '));
      });
      bot.addListener('join', function(channel, who) {
        var user;
        logger.info('%s has joined %s', who, channel);
        user = self.createUser(channel, who);
        user.room = channel;
        return self.receive(new EnterMessage(user));
      });
      bot.addListener('part', function(channel, who, reason) {
        var msg, user;
        logger.info('%s has left %s: %s', who, channel, reason);
        user = self.createUser('', who);
        user.room = channel;
        msg = new LeaveMessage(user);
        msg.text = reason;
        return self.receive(msg);
      });
      bot.addListener('quit', function(who, reason, channels) {
        var ch, msg, user, _i, _len, _results;
        logger.info('%s has quit: %s (%s)', who, channels, reason);
        _results = [];
        for (_i = 0, _len = channels.length; _i < _len; _i++) {
          ch = channels[_i];
          user = self.createUser('', who);
          user.room = ch;
          msg = new LeaveMessage(user);
          msg.text = reason;
          _results.push(self.receive(msg));
        }
        return _results;
      });
      this.bot = bot;
      return self.emit("connected");
    };

    TwitchBot.prototype._getTargetFromEnvelope = function(envelope) {
      var room, target, user;
      user = null;
      room = null;
      target = null;
      if (envelope.reply_to) {
        user = envelope;
      } else {
        user = envelope.user;
        room = envelope.room;
      }
      if (user) {
        if (user.room) {
          target = user.room;
        } else if (user.name) {
          target = user.name;
        } else if (user.reply_to) {
          target = user.reply_to;
        } else if ((typeof user.search === "function" ? user.search(/@/) : void 0) !== -1) {
          target = user;
        }
      } else if (room) {
        target = room;
      }
      return target;
    };

    return TwitchBot;

  })(Adapter);

  module.exports.use = function(chat) {
    return new TwitchBot(chat);
  };

}).call(this);
